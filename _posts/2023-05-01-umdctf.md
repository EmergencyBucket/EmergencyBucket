---
title: UMDCTF
description: Writeups for UMDCTF
published: true
layout: default
---

# Mirror Unknown

## Description

I found some unknown symbols in a nearby collapsed cave. Can you figure out what they mean?

(Note: Ancient civilizations didn't believe in whitespace of lowercase)

File: [Image](https://i.mrxbox98.me/file/2023/05/Mirror_Unkown.png)

## Solution

This image is a mirrored code of Unown from pokemon. Mirror the image then enter the runes [here](https://www.dcode.fr/pokemon-unown-alphabet)

Flag: ``UMDCTF{SINJOHRUINS}``

---

# No. 352

## Description

password 1: the name of pokemon #352 in lowercase
password 2: timetofindwhatkecleonishiding

File: [Image](https://i.mrxbox98.me/file/2023/05/hide-n-seek.jpg)

## Solution

The image contains two hidden images which both use passwords. This can be decoded by using ``steghide extract -sf filename.png``.

Flag: ``UMDCTF{KECLE0NNNNN}``

---

# Fire Type Pokemon Only

## Description

Some wannabe trainer with no pokemon left their PC connected to the internet. Watch as I hack this nerd lol.

File: [pcapng](https://i.mrxbox98.me/file/2023/05/fire-type-pokemon-only.pcapng)

## Solution

Examine the packet capture using Wireshark

Filter by ``FTP`` and scroll until you view the file ``secret`` being transferred. Open the file transfer stream and save the stream as a zip file. Unzip the file and play the video in the folder which contains the flag ``UMDCTF{its_n0t_p1kachu!!}``.

---

# YARA Trainer Gym

## Description

My pokemon aren't very strong yet so I need to slip past the sigs written by the 8 YARA gym leaders! Can you help me!!!

Note: you can run the yara rules locally with ``yara yara_rules.yar $file``

Website: ![](https://i.mrxbox98.me/file/2023/05/chrome_g9lUXGn9lf.png)

Rules:
```javascript
import "elf"
import "math"

rule rule1 {
    condition:
        uint32(0) == 0x464c457f
}

rule rule2 {
    strings:
        $rocket1 = "jessie"
        $rocket2 = "james"
        $rocket3 = "meowth"

    condition:
        all of ($rocket*)
}

rule rule3 {
    meta:
        description = "Number of sections in a binary"
     condition:
        elf.number_of_sections == 40
}

rule rule4 {
    strings:
        $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65}
        $hex2 = {5445414d524f434b4554}
        $hex3 = {696d20736f207469726564}
        $hex4 = {736c656570792074696d65}

    condition:
        ($hex1 and $hex2) or ($hex3 and $hex4)
}

rule rule5 {
    condition:
        math.entropy(0, filesize) >= 6
}

rule rule6 {
    strings:
        $xor = "aqvkpjmdofazwf{lqjm1310<" xor
    condition:
        $xor
}

rule rule7 {
    condition:
        for any section in elf.sections : (section.name == "poophaha")
}

rule rule8 {
    condition:
        filesize < 2MB and filesize > 1MB
}
```

## Solution

This is a yara ruleset. Here are all the rules explained:

* **Rule 1:** Checks if the file is a linux binary.
* **Rule 2:** Checks if the binary contains the strings, ``jessie``, ``james``, and ``meowth``.
* **Rule 3:** Checks if the binary elf file has 40 sections.
* **Rule 4:** Checks if the binary contains the strings (``somethingsomethingmalware`` and ``TEAMROCKET``) or (``im so tired`` and ``sleepy time``)
* **Rule 5:** Checks if the entropy of the file is greater than or equal to six
* **Rule 6:** Checks if the string ``aqvkpjmdofazwf{lqjm1310<`` is present in the binary
* **Rule 7:** Checks if there is a section named ``poophaha`` in the binary
* **Rule 8:** Checks if the file is between 1MB and 2MB

Lets go through this one by one and write a C++ file.

> main.cpp

```cpp
// Imports
#include <iostream>

//Dummy value for next sections
#define STRINGIZER(arg)    #arg
#define STRVAL(v)          STRINGIZER(v)

//This section is to add custom elf sections and add sections to reach the 40 count
//Source: https://blog.podkalicki.com/how-to-add-custom-section-to-elf-file/
constexpr const char commit_id[] __attribute__((section("mysection"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char build_time[] __attribute__((section("poophaha"))) = "build-time=" STRVAL(BUILD_TIME);
constexpr const char commit_id1[] __attribute__((section("mysection1"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char commit_id2[] __attribute__((section("mysection2"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char commit_id3[] __attribute__((section("mysection3"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char commit_id4[] __attribute__((section("mysection4"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char commit_id5[] __attribute__((section("mysection5"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char commit_id6[] __attribute__((section("mysection6"))) = "commit-id=" STRVAL(COMMIT_ID);
constexpr const char commit_id7[] __attribute__((section("mysection7"))) = "commit-id=" STRVAL(COMMIT_ID);

int main(int argc, char *argv[])
{
    //Ensure the string is in the binary
    std::cout << "aqvkpjmdofazwf{lqjm1310<" << std::endl;
    return (0);
}

//These strings are also needed
void jessie() {

}

void james() {

}

void meowth() {
}

void TEAMROCKET() {
}

void somethingsomethingmalware() {
}
```

Compile the file with ``gcc main.cpp -lstdc++``

Add randomness to reach the entropy and size requirement using ``dd if=<(openssl enc -aes-256-ctr -pass pass:"$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64)" -nosalt < /dev/zero) of=a.out bs=1M count=2 seek=1 iflag=fullblock``

Put this into the website to find the flag: ``UMDCTF{Y0ur3_4_r34l_y4r4_m4573r!}``

---

# Telekinetic Warfare

## Description

Someone was able to exfil a top secret document from our airgapped network! How???

File: [gif](https://i.mrxbox98.me/file/2023/05/bruh.gif)

The gif file is a bunch of qr codes. The first step is to extract it into specific frames then extract the data. The data string is encoded in base64 so once decoded and combined they make a data file. The file header can be found in a file header database and once run as a pdf file the flag can be seen as ``UMDCTF{wh0_n33d5_k1net1c_w4rfar3_anyw4ys}``

# CBC-MAC 1

## Description

Team Rocket told me CBC-MAC with arbitrary-length messages is safe from forgery. I don't think they can be trusted, so I built this oracle for it to be tested before I use it for my own important needs.

### Server-side Code
```python
import socket
import threading
from _thread import *
from Crypto import Random
from Crypto.Cipher import AES
from binascii import hexlify, unhexlify

HOST = '0.0.0.0'  # Standard loopback interface address (localhost)
PORT = 60001        # Port to listen on (non-privileged ports are > 1023)
FLAG = open('flag.txt', 'r').read()
MENU = "\nWhat would you like to do?\n\t(1) MAC Query\n\t(2) Forgery\n\t(3) Exit\n\nChoice: "
INITIAL = "Team Rocket told me CBC-MAC with arbitrary-length messages is safe from forgery. If you manage to forge a message you haven't queried using my oracle, I'll give you something in return.\n"

BS = 16 # Block Size
MAX_QUERIES = 10
   
def cbc_mac(msg, key):
    iv = b'\x00'*BS
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    x = cipher.encrypt(msg)
    print(hexlify(x))
    t = x[-16:]
    return hexlify(t)

def threading(conn):
    conn.sendall(INITIAL.encode())

    key = Random.get_random_bytes(16)
    queries = []
    while len(queries) < MAX_QUERIES:
        conn.sendall(MENU.encode())
        try:
            choice = conn.recv(1024).decode().strip()
        except ConnectionResetError as cre:
            return

        # MAC QUERY
        if choice == '1':
            conn.sendall(b'msg (hex): ')
            msg = conn.recv(1024).strip()

            try:
                msg = unhexlify(msg)
                if (len(msg) + BS) % BS != 0:
                    conn.sendall(f'Invalid msg length. Must be a multiple of BS={BS}\n'.encode())
                else:
                    queries.append(msg)
                    t = cbc_mac(msg, key)
                    conn.sendall(f'CBC-MAC(msg): {t.decode()}\n'.encode())
            except Exception as e:
                conn.sendall(b'Invalid msg format. Must be in hexadecimal\n')

        # FORGERY (impossible as I'm told)
        elif choice == '2':
            conn.sendall(b'msg (hex): ')
            msg = conn.recv(1024).strip()
            conn.sendall(b'tag (hex): ')
            tag = conn.recv(1024).strip()

            try:
                msg = unhexlify(msg)
                if (len(msg) + BS) % BS != 0:
                    conn.sendall(f'Invalid msg length. Must be a multiple of BS={BS} bytes\n'.encode())
                elif len(tag) != BS*2:
                    conn.sendall(f'Invalid tag length. Must be {BS} bytes\n'.encode())
                elif msg in queries:
                    conn.sendall(f'cheater\n'.encode())
                else:
                    t_ret = cbc_mac(msg, key)
                    if t_ret == tag:
                        conn.sendall(f'If you reach this point, I guess we need to find a better MAC (and not trust TR). {FLAG}\n'.encode())
                    else:
                        conn.sendall(str(t_ret == tag).encode() + b'\n')
            except Exception as e:
                conn.sendall(b'Invalid msg format. Must be in hexadecimal\n')

        else:
            if choice == '3': # EXIT
                conn.sendall(b'bye\n')
            else: # INVALID CHOICE
                conn.sendall(b'invalid menu choice\n')
            break


    if len(queries) > MAX_QUERIES:
        conn.sendall(f'too many queries: {len(queries)}\n'.encode())
    conn.close()


if __name__ == "__main__":
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen()
        while True:
            conn, addr = s.accept()
            print(f'new connection: {addr}')
            start_new_thread(threading, (conn, ))
        s.close()
```
## Solution
Essentially the server runs AES-128 in CBC mode with a fixed initial vector everytime you query that function. You can ask it to encrypt blocks a maximum of 10 times, and then you need to give it an input and output that you haven't already queried from the server. Since the key doesn't change and the initial vector is always the same, the encryption of each block (ignoring the CBC mode's XORing with the previous block) is deterministic. We can exploit this by asking it the output of some block(it doesn't matter what value this is), and then, in the next query giving it two blocks: the block we gave it earlier and 0. This will result in the output being equivalent to if we just put in the output of the first random block into the program(since anything XOR 0 is just the first value). An example of this is action is shown in the screenshot below.

This gives us the flag: ``UMDCTF{Th!s_M@C_Sch3M3_1s_0nly_S3cur3_f0r_f!xed_l3ngth_m3ss4g3s_78232813}``

# Bulbeuler

## Description

Bulbasaur told me they are the next Euler

### Generator Sagemath File

```python
FLAG = open('flag.txt', 'r').read()

flag_bytes = [ord(c) for c in FLAG]
flag_bits = ''.join([f'{num:08b}' for num in flag_bytes])

p = random_prime(2^256)
G = GF(p, modulus="primitive")
g = G.gen()
m = p-1

print(f'p: {p}')
for bit in flag_bits:
	x = G.random_element()
	if bit == '1':
		y = m-x
	else:
		y = G.random_element()

	print(f'{g^x}, {g^y}')
```

## Solution
The encryption script creates a finite field of some order $p$, where $p$ is a prime $\leq2^{256}$. From there $m$ is calculated to be $p-1$. $g$ is a generator of the finite field. For each bit in the flag, a random element from the field $x$ is selected. If the bit is 1, $y=m-x$, otherwise $y$ is also a random element from the field. $g^x$ and $g^y$ are both given for each of the bits. $p$ is also provided. So the ultimate crux here is to somehow be able to check if $y=m-x$. If it is, then $g^y=g^{m-x}=g^mg^{-x}$. Via Fermat's Little Theorem, $g^m=1$ in the field. What we are left with is then just $g^y=g^{-x}=g^{x^{-1}}$. We already have $g^x$, so all that's left is to calculate its inverse and check if it is equal to y. In a finite field, the inverse is modular inverse, which we can calculate using `pow(gx, -1, p)` in python. The solve then looks something like this:
```python
from Crypto.Util.number import long_to_bytes as l2b
f = open("output.txt","r").read().split("\n")
p = int(f[0].split()[1])
bits = ""
for i in range(1,len(f)):
    f[i] = f[i].split(", ")
    gx = int(f[i][0])
    gy = int(f[i][1])
    gx_inverse = pow(gx,-1,p)
    if gx_inverse == gy:
        bits += "1"
    else:
        bits += "0"
print(l2b(int(bits,2)))
```
This yields the flag: ```UMDCTF{I_d0nt_th1nk_bulby_!s_th3_n3xt_3ul3r_tbh}```

# CBC_MAC 2

## Description

### Server-side Code
```python
import socket
import threading
from _thread import *
from Crypto import Random
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes as l2b
from binascii import hexlify, unhexlify

HOST = '0.0.0.0'  # Standard loopback interface address (localhost)
PORT = 60002        # Port to listen on (non-privileged ports are > 1023)
FLAG = open('flag.txt', 'r').read()
MENU = "\nWhat would you like to do?\n\t(1) MAC Query\n\t(2) Forgery\n\t(3) Exit\n\nChoice: "
INITIAL = "I came up with a scheme that might just work. Definitely not trusting those TR peeps anymore. I'm not sure how to prove the security of this besides finding an attacker that can do it (and that's where you come in). Once again, if you manage to forge a message you haven't queried using my oracle, I'll give you something in return.\n"

BS = 16 # Block Size
MAX_QUERIES = 10

def cbc_mac(msg, key):
    iv = b'\x00'*BS
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    ct = cipher.encrypt(msg + l2b(len(msg)//BS, BS))
    print(ct)
    t = ct[-16:]
    return hexlify(t)

def threading(conn):
    conn.sendall(INITIAL.encode())

    key = Random.get_random_bytes(16)
    queries = []
    while len(queries) < MAX_QUERIES:
        conn.sendall(MENU.encode())
        try:
            choice = conn.recv(1024).decode().strip()
        except ConnectionResetError as cre:
            return

        # MAC QUERY
        if choice == '1':
            conn.sendall(b'msg (hex): ')
            msg = conn.recv(1024).strip()

            try:
                msg = unhexlify(msg)
                if (len(msg) + BS) % BS != 0:
                    conn.sendall(f'Invalid msg length. Must be a multiple of BS={BS}\n'.encode())
                else:
                    queries.append(msg)
                    t = cbc_mac(msg, key)
                    conn.sendall(f'CBC-MAC(msg || <|msg|>): {t.decode()}\n'.encode())
            except Exception as e:
                conn.sendall(b'Invalid msg format. Must be in hexadecimal\n')
                
        # FORGERY
        elif choice == '2':
            conn.sendall(b'msg (hex): ')
            msg = conn.recv(1024).strip()
            conn.sendall(b'tag (hex): ')
            tag = conn.recv(1024).strip()

            try:
                msg = unhexlify(msg)
                if (len(msg) + BS) % BS != 0:
                    conn.sendall(f'Invalid msg length. Must be a multiple of BS={BS} bytes\n'.encode())
                elif len(tag) != BS*2:
                    conn.sendall(f'Invalid tag length. Must be {BS} bytes\n'.encode())
                elif msg in queries:
                    conn.sendall(f'cheater\n'.encode())
                else:
                    t_ret = cbc_mac(msg, key)
                    if t_ret == tag:
                        conn.sendall(f'I hope this line never runs, but if it does, here you go: {FLAG}\n'.encode())
                    else:
                        conn.sendall(str(t_ret == tag).encode() + b'\n')
            except Exception as e:
                conn.sendall(b'Invalid msg format. Must be in hexadecimal\n')

        else:
            if choice == '3': # EXIT
                conn.sendall(b'bye\n')
            else: # INVALID CHOICE
                conn.sendall(b'invalid menu choice\n')
            break


    if len(queries) > MAX_QUERIES:
        conn.sendall(f'too many queries: {len(queries)}\n'.encode())
    conn.close()
            

if __name__ == "__main__":
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen()
        while True:
            conn, addr = s.accept()
            print(f'new connection: {addr}')
            start_new_thread(threading, (conn, ))
        s.close()
```

## Solution
This challenge is very similar to CBC-MAC 1, but at the end of each query, a block with the length of the query is appended to the message. In this case we can give it some block to process, let's call this block $a$. The output will then be $AES(1^\wedge AES(a))$. If we input $a$, 1 and the output of the previous query, the new output will essentially be $AES(3^\wedge AES(0))$, since the xor of the output of the last query by itself is simply 0. You'll notice that this output is now completely independent of $a$. We can simply then query some replacement $b$, and the output of b,1,$AES(1^\wedge AES(b))$ will be the earlier output. This is shown below in the image.
This gets us the flag: ``UMDCTF{W3lp_l00k5_l!k3_I_n33d_t0_ch4ng3_th1s_ag41n_s4d_f4ce_3m0j1_927323}``

# Reduce Thyself
## Description
I don't think Pokemon really like the idea of self-reducibility...

RESOURCE: 10.5.1 in this textbook may prove useful.

### Server-side Code
```python
import socket
import random
import threading
from _thread import *
from Crypto.Util.number import long_to_bytes as l2b, bytes_to_long as b2l, getPrime, isPrime, inverse
from math import gcd
from binascii import hexlify, unhexlify

HOST = '0.0.0.0'  # Standard loopback interface address (localhost)
PORT = 60003        # Port to listen on (non-privileged ports are > 1023)
FLAG = open('flag.txt', 'r').read().strip().encode()

def decrypt(flag_ct, ct, d, n):
    pt = 'null'
    print(isPrime(ct))
    print(ct)
    if isPrime(ct) and ct != flag_ct:
        pt = hexlify(l2b(pow(ct, d, n))).decode()
    return pt

def gen_params():
    while True:
        p,q = getPrime(1024), getPrime(1024)
        n = p*q
        e = 0x10001
        phi = (p-1)*(q-1)
        if gcd(phi, e) == 1:
            d = inverse(e, phi)
            break
    return n,e,d

def threading(conn):
    n,e,d = gen_params()
    flag_ct = pow(b2l(FLAG), e, n)
    print(f'n: {n}\ne: {e}\nd: {d}')
    conn.sendall(f'n: {hex(n)}\ne: {hex(e)}\nflag_ct: {hex(flag_ct)}\n\n'.encode())
    while True:
        conn.sendall(b'Gimme ct (hex): ')
        try:
            ct = int(conn.recv(1024).strip().decode(), 16)
        except Exception as e:
            conn.sendall(b'invalid ct')
            break
        
        pt = decrypt(flag_ct, ct, d, n)
        conn.sendall(f'result: {pt}\n\n'.encode())

    conn.close() 


if __name__ == "__main__":
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen()
        while True:
            conn, addr = s.accept()
            print(f'new connection: {addr}')
            start_new_thread(threading, (conn, ))
        s.close()
```

## Solution
The solution is basically just a chosen ciphertext attack on RSA, but with a few caveats. How chosen ciphertext attacks on RSA is explained well [here](https://crypto.stackexchange.com/questions/2323/how-does-a-chosen-plaintext-attack-on-rsa-work). The caveats are just that the plaintext we send back has to be prime and that the full ciphertext + ``\n`` encoding has to be less than or equal to 512 bytes (the server seems to cut off anything longer). The resource provided seems to indicate that either this will be pretty easily possible, or almost impossible, with no middle ground. So we can just iterate through the first 10k possible values of a possible log base and then ping the server for the result if it is found, or start over if we can't find it.
```python
from Crypto.Util.number import isPrime, long_to_bytes as l2b
from itertools import dropwhile
import socket

def validate(num):
    thing = pow(num,e,n) * flag_ct % n
    return not isPrime(thing) or len(hex(thing)[2:].encode()) >= 512

host = "0.cloud.chals.io"
port = 33047
while True:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, port))
        data = s.recv(2048).decode().replace("\n"," ")
        data = data.split(" ")
        n = int(data[1], 16)
        e = int(data[3], 16)
        flag_ct = int(data[5], 16)
        try:
            s.recv(1024)
            r = dropwhile(validate, range(2,10000))
            num = next(r)
            thing = hex(pow(num,e,n) * flag_ct % n)[2:]
            s.sendall(thing.encode())
            a = s.recv(1024).decode().strip().split(" ")[1]
            a = int(a,16)
            a = a // num
            print(l2b(a))
            break
        except StopIteration:
            continue
```
This solve yields the flag ``UMDCTF{s3lf_r3duc!bility_1s_n0t_ju5t_f0r_DH_97912837923}``

# AES-TR

## Description

Team Rocket came up with their own symmetric encryption scheme they claim is "top-notch". I told 'em they should release the details of the scheme due to Kirchoff's Principle, however I received an oracle instead. Let's prove that this scheme is definitely not IND-CPA secure.

### Server-Side Code
```python
import socket
import random
import threading
from _thread import *
from Crypto import Random
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes as l2b, bytes_to_long as b2l
from Crypto.Util.strxor import strxor
from binascii import hexlify, unhexlify

HOST = '0.0.0.0'  # Standard loopback interface address (localhost)
PORT = 60000        # Port to listen on (non-privileged ports are > 1023)
FLAG = "UMDCTF{TEST}"
MENU = "\nWhat would you like to do?\n\t(1) Encryption Query\n\t(2) Check Bit\n\t(3) Exit\n\nChoice: "
INITIAL = "Welcome to the best symmetric encryption scheme ever. I'll give you a flag if you can prove this scheme insecure under IND-CPA, but I know it's impossible!! >:)\n"

BS = 16 # Block Size
MS = 30 # Maximum blocks per query
MAX_QUERIES = 10
NUM_BITS = 128

def encrypt(m):
    m = unhexlify(m)
    iv = Random.get_random_bytes(16)
    key = Random.get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_ECB)

    blocks = [m[i:i+BS] for i in range(0, len(m), BS)]
    ct = iv
    for i in range(len(blocks)):
        ctr = l2b((b2l(iv)+i+1) % pow(2,BS*8))
        ctr = b'\x00'*(BS - len(ctr)) + ctr # byte padding if ctr < pow(2,BS*8 - 1)
        ct += cipher.encrypt(strxor(ctr, blocks[i]))

    assert len(ct) - len(m) == BS
    return hexlify(ct)
    

def threading(conn):
    conn.sendall(INITIAL.encode())

    for bit in range(NUM_BITS):
        queries = 0
        b = random.randint(0,1)
        print(b)
        while queries < MAX_QUERIES:
            conn.sendall(MENU.encode())
            try:
                choice = conn.recv(1024).decode().strip()
            except ConnectionResetError as cre:
                return

            # ENCRYPTION QUERY
            if choice == '1':
                queries += 1
                conn.sendall(b'm0 (hex): ')
                m0 = conn.recv(1024).strip()
                conn.sendall(b'm1 (hex): ')
                m1 = conn.recv(1024).strip()
                if (len(m0) % 2 != 0) or ((len(m0) // 2) % BS != 0) or ((len(m0) // (2*BS)) > MS):
                    conn.sendall(b'invalid m0\n')
                elif (len(m1) % 2 != 0) or ((len(m1) // 2) % BS != 0) or ((len(m1) // (2*BS)) > MS):
                    conn.sendall(b'invalid m1\n')
                elif len(m0) != len(m1):
                    conn.sendall(b'messages must be same length\n')
                else:
                    if b == 0:
                        ct = encrypt(m0)
                    else:
                        ct = encrypt(m1)
                    conn.sendall(b'ct: ' + ct + b'\n')
                    continue

            # CHECK BIT
            elif choice == '2':
                conn.sendall(b'Bit (b) guess: ')
                b_guess = conn.recv(1024).strip().decode()
                if b_guess == str(b):
                    conn.sendall(b'correct!\n')
                    break
                else:
                    conn.sendall(b'wrong\n')
            
            # EXIT
            elif choice == '3':
                conn.sendall(b'bye homie\n')
            
            # INVALID
            else:
                conn.sendall(b'invalid menu choice\n')

            # close connection on exit, invalid choice, wrong bit guess, invalid encryption query
            conn.close()
            return

        if queries > MAX_QUERIES:
            conn.sendall(f'too many queries: {queries}\n'.encode())
            conn.close()
            return
            
    # Bits guessed correctly
    conn.sendall(f'okay, okay, here is your flag: {FLAG}\n'.encode())
    conn.close()


if __name__ == "__main__":
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen()
        while True:
            conn, addr = s.accept()
            print(f'new connection: {addr}')
            start_new_thread(threading, (conn, ))
        s.close()
```

# Solution
In the challenge, for every query we provide two blocks that go through AES and then we get one depending on what the current bit is. Using this, we are meant to guess the bit and move on. If we guess 10 bits in a row, we get the flag. In essence, we are trying to differentiate two sets of blocks when they have been put through AES ECB mode. This is important because even though the initial vector is random, it only increments by one and the input to the next block for each set isn't XORed with the output of the previous block's encryption. What we can do is try to ensure that one of the blocks going into the AES encryption is the same when it comes out. This way we can look for a repeat in the output blocks. If one exists, we know that that is the block associated with 0 (or 1 depending on how you want to do this). However, the initial vector increments by one. How the bits change depends on how many ones are at the end of the initial vector when the encryption first happens. We can test for some x number of 0's every block that we put in (besides the first block which we are trying to match to). This means as long as the initial vector had somewhere between 0-14 1s at the end of its binary value, we should be able to see a repeat. If not, we can try again as we get 10 queries per bit. The code for this solve is shown below:
```python
from Crypto.Util.number import long_to_bytes as l2b, bytes_to_long as b2l

def generate0():
    y = [0]
    for i in range(14):
        x = (1 << i) - 1
        z = x + i + 1
        y.append(z ^ x)
    return "".join([hex(i)[2:].zfill(32) for i in y])

def generate1():
    return "".zfill(480)

def verify(a):
    a = a[1:]
    if len(a) > len(set(a)):
            return 0
    return 1

def checkIV(a):
    a = "{0:b}".format(a)
    return a[-14:].count("1") <= 13

import socket
host = "0.cloud.chals.io"
port = 24524

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((host, port))
    s.recv(1024)
    s.recv(1024)
    while True:
        s.sendall('1\n'.encode())
        s.recv(1024)
        s.sendall((generate0()+'\n').encode())
        s.recv(1024)
        s.sendall((generate1()+'\n').encode())
        received_next = False
        data = s.recv(1024).decode()
        if "Choice:" in data:
            received_next = True
            data = data.split("\n")
            data = data[0][4:]
        else:
            data = data[4:-1]
        data = [int(data[i:i+32],16) for i in range(0,len(data),32)]
        if checkIV(data[0]):
            if not received_next:
                s.recv(1024)
            s.sendall('2\n'.encode())
            s.recv(1024)
            s.sendall((str(verify(data))+'\n').encode())
            a = s.recv(1024).decode()
            if "UMD" in a:
                print(a)
                break
            if not "Choice:" in a:
                a = s.recv(1024).decode()
                if "UMD" in a:
                    print(a)
                    break
        else:
            if not received_next:
                s.recv(1024)
            continue
```
This gets us the flag: ``UMDCTF{N0t_@_v3ry_gr34t_5ch3m3_8ae61b7910099}``